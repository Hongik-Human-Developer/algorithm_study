# hash

1. 배열

    내부 인덱스를 이용해 자료의 검색이 한번에 이루어지기 때문에 빠른 속도를 보이지만, 반면 데이터의 삽입, 삭제시 많은 데이터가 밀리거나 빈자리를 채우기 위해 이동해야 하기 때문에 많은 시간이 소요된다.

​

2. 연결 리스트

    삽입, 삭제시 인근 노드들의 참조값만 수정해줌으로써 빠른 처리가 가능하다.

    단, 처음노드와 마지막 노드 이외의 위치에서 데이터를 삽입이나 삭제할 경우나 데이터를 검색할 경우, 해당 노드를 찾기 위해 처으부터 순회 검색을 해야 하기 때문에 데이터 수가 많아 질 수록 효율이 떨어질 수 밖에 없는 구조이다.

​

→ 이러한 한계를 극복하기 위해 제시된 방법이 해쉬 (Hash)이다.



## hash의 기본 개념

Hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다.

데이터의 삽입과 삭제시 기존 데이터를 밀어내거나 채우는 작업이 필요 없도록 '특별한 알고리즘'을 이용하여 데이터와 연관된 고유한 숫자를 만들더 낸뒤, 이를 인덱스로 사용한다.

특정 데이터가 저장되는 인덱스를 그 데이터만의 고유한 위치이기 때문에 삽입시 다른 데이터의 사이에 끼어들거나, 삭제시 다른 데이터로 채울 필요가 없으므로 삽입과 삭제시 데이터의 이동이 없도록 만들어진 구조​이다.

해쉬가 내부적으로 사용하는 배열을 Hash Table이라고 하며, 그 크기에 따라 성능 차이가 날 수 있다.



## hash code

Hash는 Hash Table을 이용하여 데이터를 저장한다.

이 때 '특별한 알고리즘'을 이용하여 데이터의 고유한 숫자값을 만들어 인덱스로 사용하는데, 이 알고리즘을 구현한 메소드를 Hash Method라고 하며, Hash Method에 의해 반환된 데이터 고유의 숫자 값을 Hash Code라고 한다.

Java에서는 Object 클래스의 hashCode()라는 메소드를 이용하여 모든 객체의 Hash Code를 쉽게 구할 수 있다.

-  hashCode를 구현하는 방법

    Hash Method를 구현하는 방법은 여러가지가 있지만 가장 간단한 방법으로는 나머지 연산자를 이용하는 것이다.

    데이터의 고유한 hashCode 를 구한 뒤 hashCode를 테이블의 크기로 나머지 연산을 한 결과를 해당 데이터의 인덱스로 사용하는 것이다.

    예를들어 "a", "b", "c"의 hashCode가 각각 97, 98 ,99 라고 하고 Hash Table의 크기가 10이라고 했을 때 테이블에 저장될 인덱스는 다음과 같다.
    ```java
    97 % 10 = 7
    98 % 10 = 8
    99 % 10 = 9
    ```

    즉, Hash Table의 인덱스 7에는 "a"를 저장하고 8에는 "b", 9에는 "c"를 저장하는 방식이다.

    이후에 "a"를 검색할 때에는 "a"의 hashCode를 가지고 나머지 연산을 한 결과인 7번 인덱스를 바로 참조하여 데이터를 꺼낼 수 있다.
​

    또다른 예를 들어 보자

    4, 8, 12, 16, 20, 24, 28, 32 라는 hashCode를 가진 데이터가 있다고 했을 때 데이터를 저장하기 위해 Hash Table의 크기를 8로 지정했다면 테이블에 저장될 인덱스는 다음과 같다.

    ```java
    4 % 8 = 4
    8 % 8 = 0
    12 % 8 = 4
    16 % 8 = 0
    20 % 8 = 4
    24 % 8 = 0
    28 % 8 = 4
    32 % 8 = 0
    ```

    데이터를 저장하기 위한 인덱스가 0번과 4번에 집중되는 것을 볼 수 있다.

    이처럼 hashCode가 다르더라도 나머지 연산을 한 결과는 같을 수 있으므로 Hash Table의 동일한 인덱스에 저장을 시도하려 할 경우 문제가 발생한다.

    이렇게 저장하려는 위치에 이미 다른 데이터가 있어서 저장을 할 수 없는 현상을 충돌(collision)이라고 하며 이런 충돌을 최소화 하기 위한 방법으로는 나머지 연산의 값이 최대한 중복되지 않도록 테이블의 크기를 소수(prime number)로 만드는 것이다.

    ​

    다음은 8보다 큰 소수인 11을 테이블의 크기로 지정했을 때 각 데이터들이 테이블에 저장될 인덱스 값이다.

    ```java
    4 % 11 = 4
    8 % 11 = 8
    12 % 11 = 1
    16 % 11 = 5
    20 % 11 = 9
    24 % 11 = 2
    28 % 11 = 6
    32 % 11 = 10
    ```
    이제는 충돌이 발생하지 않는다. 

    하지만 Hash Table의 크기를 소수로 만드는 것은 충돌을 줄이는 방법이지 해결하기 위한 방법은 아니다. 

    추가적으로 10을 저장하려고 한다면 10 % 11 = 10 로 되므로 이미 10번의 인덱스에는 32가 들어있기 때문에 충돌이 발생한다.



    이처럼 충돌이 발생할 경우 이를 해결하기 위한 방법이 필요하며 충돌 해결 방법으로 개방주소법과 분리연결법 두가지가 있다.

## 분리 연결법
![image](https://user-images.githubusercontent.com/45223821/108028959-ff30c880-706f-11eb-88d5-7cd5d643ac20.png)

Hash Table에 이미 다른 데이터가 저장되어 있을 경우, 데이터를 저장하지 못하는 충돌이 발생한다.

이를 해결하기 위한 방법으로 

1. 개방 주소법

2. 분리 연결법

이 존재하지만, 개방 주소법은 충돌이 많이 일어날 경우, 심각한 성능저하가 발생할 수 있다.

​

분리 연결법은 Hash Table에 연결 리스트에서 사용하는 Node 객체를 저장하는 것이다.

즉, Hash Table의 셀마다 연결 리스트를 하나씩 저장하고 충돌이 발생하는 데이터는 연결 리스트의 다음 노드로 계속 추가하는 것이다.

​
이후에 데이터를 검색할 때에는, Hash Table의 인덱스를 찾은 후, 셀에 연결된 리스트를 순차적으로 탐색하며 찾으려는 HashCode와 저장된 노드의 HashCode를 비교하는 것이다.


   


---
### Ref
1. https://whatisthenext.tistory.com/81

2. https://hyeonstorage.tistory.com/265 (전체적 내용)

- 분리 연결법과 Hash Table 포스팅
<https://blog.naver.com/5550304/222185247379>